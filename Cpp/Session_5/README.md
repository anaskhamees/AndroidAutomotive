# Modern C++



## 1. Type Information

The `<typeinfo>` library in C++ is part of the C++ Standard Library and provides support for runtime type identification (RTTI). RTTI allows the type of an object to be determined during program execution. This is particularly useful in scenarios where you are dealing with polymorphic classes and need to identify the actual derived type of an object pointed to by a base class pointer or reference.

### Key Components of `<typeinfo>`:

1. **`std::type_info`**: The primary class provided by `<typeinfo>`. It represents type information generated by the compiler.
2. **`typeid` operator**: Used to retrieve a `std::type_info` object representing the type of an expression or type.

### Important Members of `std::type_info`:

- **`name()`**: Returns an implementation-defined, null-terminated character string representing the name of the type.
- **`before(const std::type_info &rhs) const`**: Returns `true` if the type precedes `rhs` in the implementation's internal ordering of types.
- **`operator==` and `operator!=`**: Compares two `std::type_info` objects for equality or inequality.
- **`operator=`**: Assignment operator.
- **`hash_code() const`**: Returns a hash code representing the type, useful for hashing.





### Example 1: Using `typeid` with Built-in Types

```c++
#include <iostream>
#include <typeinfo>

int main() {
    int a = 42;
    double b = 3.14;
    char c = 'A';
    bool d = true;

    std::cout << "Type of a: " << typeid(a).name() << '\n';
    std::cout << "Type of b: " << typeid(b).name() << '\n';
    std::cout << "Type of c: " << typeid(c).name() << '\n';
    std::cout << "Type of d: " << typeid(d).name() << '\n';

    return 0;
}
```

### Example 2: Using `typeid` with Standard Library Types

```c++
cppCopy code#include <iostream>
#include <typeinfo>
#include <vector>
#include <string>

int main() {
    std::vector<int> vec;
    std::string str = "Hello, World!";
    const char* cstr = "C-String";

    std::cout << "Type of vec: " << typeid(vec).name() << '\n';
    std::cout << "Type of str: " << typeid(str).name() << '\n';
    std::cout << "Type of cstr: " << typeid(cstr).name() << '\n';

    return 0;
}
```

### Example 3: Using `typeid` with Expressions

```c++
#include <iostream>
#include <typeinfo>

int main() {
    int x = 10;
    double y = 5.5;

    auto sum = x + y;

    std::cout << "Type of x: " << typeid(x).name() << '\n';
    std::cout << "Type of y: " << typeid(y).name() << '\n';
    std::cout << "Type of sum (x + y): " << typeid(sum).name() << '\n';

    return 0;
}
```

### Example 4: Comparing Type Information

```c++
#include <iostream>
#include <typeinfo>

int main() {
    int a = 1;
    float b = 1.0f;

    if (typeid(a) == typeid(b)) {
        std::cout << "a and b are of the same type\n";
    } else {
        std::cout << "a and b are of different types\n";
    }

    return 0;
}
```

### Example 5: Using `hash_code` and `before`

```c++
#include <iostream>
#include <typeinfo>

int main() {
    int i = 10;
    double d = 10.0;

    const std::type_info& intTypeInfo = typeid(i);
    const std::type_info& doubleTypeInfo = typeid(d);

    std::cout << "Hash code of int: " << intTypeInfo.hash_code() << '\n';
    std::cout << "Hash code of double: " << doubleTypeInfo.hash_code() << '\n';

    if (intTypeInfo.before(doubleTypeInfo)) {
        std::cout << "int comes before double\n";
    } else {
        std::cout << "double comes before int\n";
    }

    return 0;
}
```

### Important Notes:

- The `name()` function returns an implementation-defined, null-terminated character string representing the name of the type. The exact string may vary between different compilers and may not be human-readable.
- The `hash_code()` function provides a hash value for the type, which can be useful for storing types in hash-based containers.
- The `before()` function compares two `std::type_info` objects to determine the internal ordering of types as defined by the implementation.





### Example Usage:

#### Basic Usage of `typeid` and `std::type_info`:

```c++
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual ~Base() = default; // Polymorphic base class
};

class Derived : public Base {};

int main() {
    Base base;
    Derived derived;
    Base* basePtr = &derived;

    // Retrieve type information using typeid
    const std::type_info& baseTypeInfo = typeid(base);
    const std::type_info& derivedTypeInfo = typeid(derived);
    const std::type_info& basePtrTypeInfo = typeid(*basePtr);

    std::cout << "Type of base: " << baseTypeInfo.name() << '\n';
    std::cout << "Type of derived: " << derivedTypeInfo.name() << '\n';
    std::cout << "Type of basePtr: " << basePtrTypeInfo.name() << '\n';

    // Compare type information
    if (baseTypeInfo == derivedTypeInfo) {
        std::cout << "base and derived are of the same type\n";
    } else {
        std::cout << "base and derived are of different types\n";
    }

    if (derivedTypeInfo == basePtrTypeInfo) {
        std::cout << "derived and basePtr point to the same type\n";
    } else {
        std::cout << "derived and basePtr point to different types\n";
    }

    return 0;
}
```

#### Example with Hash Code and `before`:

```c++
#include <iostream>
#include <typeinfo>

class A {};
class B {};

int main() {
    const std::type_info& aTypeInfo = typeid(A);
    const std::type_info& bTypeInfo = typeid(B);

    std::cout << "Hash code of A: " << aTypeInfo.hash_code() << '\n';
    std::cout << "Hash code of B: " << bTypeInfo.hash_code() << '\n';

    if (aTypeInfo.before(bTypeInfo)) {
        std::cout << "A comes before B\n";
    } else {
        std::cout << "B comes before A\n";
    }

    return 0;
}
```

### Important Notes:

1. **Polymorphic Classes**: For `typeid` to work correctly with polymorphic objects (i.e., objects accessed through base class pointers or references), the base class must have at least one virtual function (typically a virtual destructor).
2. **Compiler-Specific Name Strings**: The string returned by `name()` is implementation-defined and can vary between compilers. It's not guaranteed to be human-readable or stable across different compiler versions.
3. **No RTTI**: Some embedded or performance-critical systems might disable RTTI for performance reasons. This is controlled by compiler options (e.g., `-fno-rtti` in GCC/Clang).



## 2. Initializer List

In modern C++, initializer lists provide a convenient way to initialize containers, arrays, and classes with a list of values. They improve code readability and simplify the initialization process. Here's a detailed explanation of initializer lists in C++11 and later versions, including their usage, syntax, and examples.

### Initializer List Syntax

An initializer list is created using curly braces `{}`. It can be used in various contexts, such as initializing containers, arrays, or class members.

### Examples

#### 1. Initializing Standard Library Containers

You can initialize standard library containers like `std::vector`, `std::array`, and `std::map` using initializer lists.

```c++
#include <iostream>
#include <vector>
#include <array>
#include <map>

int main() {
    // Initializing std::vector
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // Initializing std::array
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    
    // Initializing std::map
    std::map<int, std::string> map = {{1, "one"}, {2, "two"}, {3, "three"}};
    
    // Print vector elements
    std::cout << "Vector elements: ";
    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;
    
    // Print array elements
    std::cout << "Array elements: ";
    for (int a : arr) {
        std::cout << a << " ";
    }
    std::cout << std::endl;
    
    // Print map elements
    std::cout << "Map elements: ";
    for (const auto& pair : map) {
        std::cout << "{" << pair.first << ", " << pair.second << "} ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 2. Initializing Arrays

Arrays can be initialized using initializer lists.

```c++
#include <iostream>

int main() {
    // Initializing array
    int arr[] = {1, 2, 3, 4, 5};
    
    // Print array elements
    std::cout << "Array elements: ";
    for (int a : arr) {
        std::cout << a << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 3. Initializing Class Members

You can use initializer lists to initialize class members via constructors.

```c++
#include <iostream>
#include <initializer_list>

class MyClass {
public:
    MyClass(std::initializer_list<int> list) {
        for (int value : list) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MyClass obj = {1, 2, 3, 4, 5};
    return 0;
}
```

### `std::initializer_list`

The `std::initializer_list` is a standard library type that represents a fixed-size sequence of objects. It is commonly used in constructors to accept initializer lists.

#### Example Using `std::initializer_list`

```c++
#include <iostream>
#include <initializer_list>

class MyClass {
public:
    MyClass(std::initializer_list<int> list) {
        for (int value : list) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MyClass obj = {1, 2, 3, 4, 5};
    return 0;
}
```

In this example, `std::initializer_list<int>` allows the constructor of `MyClass` to accept an initializer list of integers.

### Aggregate Initialization

In C++11 and later, you can use initializer lists for aggregate initialization, which allows initializing aggregate types (like structs and arrays) directly.

#### Example of Aggregate Initialization

```c++
#include <iostream>

struct Point {
    int x;
    int y;
};

int main() {
    // Aggregate initialization of struct
    Point p = {10, 20};
    
    std::cout << "Point coordinates: (" << p.x << ", " << p.y << ")" << std::endl;
    
    return 0;
}
```

### Uniform Initialization

Uniform initialization (also known as brace-enclosed initialization) was introduced in C++11 to provide a consistent syntax for initializing objects and to prevent narrowing conversions.

#### Example of Uniform Initialization

```c++
#include <iostream>
class MyClass {
public:
    int a;
    double b;
    MyClass(int a, double b) : a(a), b(b) {}
};

int main() {
    // Uniform initialization
    MyClass obj{10, 3.14};
    
    std::cout << "Object values: a = " << obj.a << ", b = " << obj.b << std::endl;
    
    return 0;
}
```
